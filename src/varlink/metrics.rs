//! This code is adapted from the code generated by `zlink-codegen` from Varlink IDL.

use serde::{Deserialize, Serialize};
use zlink::{proxy, ReplyError};


/// Proxy trait for calling methods on the interface.
#[proxy("io.systemd.Metrics")]
pub trait Metrics {
    /// A struct representing various metric value types. A metric can be of one type
    /// [Requires 'more' flag]
    #[zlink(more)]
    async fn list(&mut self) -> zlink::Result<impl futures_util::Stream<Item = zlink::Result<Result<ListOutput, MetricsError>>>>;
    /// Method to get the metric families
    /// [Requires 'more' flag]
    #[zlink(more)]
    async fn describe(&mut self) -> zlink::Result<impl futures_util::Stream<Item = zlink::Result<Result<DescribeOutput, MetricsError>>>>;
}

/// A struct representing various metric value types. A metric can be of one type.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
pub struct MetricValue {
    /// A string value type
    #[serde(rename = "string")]
    pub string: Option<String>,
    /// An int value type
    #[serde(rename = "int")]
    pub int: Option<i64>,
    /// A boolean value type
    #[serde(rename = "bool")]
    pub bool: Option<bool>,
}

impl MetricValue {
    /// Returns the string value if present
    pub fn as_str(&self) -> Option<&str> {
        self.string.as_deref()
    }

    /// Returns the string value or a default
    pub fn as_string<'a>(&'a self, default: &'a str) -> &'a str {
        self.string.as_deref().unwrap_or(default)
    }

    /// Returns the int value as u64 or a default
    pub fn as_int(&self, default: u64) -> u64 {
        self.int.map(|v| v as u64).unwrap_or(default)
    }

    /// Returns the bool value if present
    pub fn as_bool(&self) -> Option<bool> {
        self.bool
    }

    /// Returns the bool value or a default
    pub fn bool_or(&self, default: bool) -> bool {
        self.bool.unwrap_or(default)
    }
}

/// Output parameters for the List method.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ListOutput {
    pub name: String,
    pub value: MetricValue,
    pub object: Option<String>,
    pub fields: Option<std::collections::HashMap<String, serde_json::Value>>,
}

impl ListOutput {
    /// Returns the name of the metric
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Returns the name of the metric
    pub fn name_suffix(&self) -> &str {
        self.name.rsplit_once('.').map(|(_, suffix)| suffix).unwrap_or(&self.name)
    }

    /// Returns the value of the metric
    pub fn value(&self) -> &MetricValue {
        &self.value
    }

    /// Returns the object name if present
    pub fn object(&self) -> Option<&str> {
        self.object.as_deref()
    }

    /// Returns the object name or empty string if not present
    pub fn object_name(&self) -> String {
        self.object.as_deref().unwrap_or("").replace('-', "_")
    }

    /// Returns the string value or default_value if not present
    pub fn value_as_string<'a>(&'a self, default_value: &'a str) -> &'a str {
        self.value.as_string(default_value)
    }

    /// Returns the int value as u64 or default_value if not present
    pub fn value_as_int(&self, default_value: u64) -> u64 {
        self.value.as_int(default_value)
    }

    /// Returns the bool value if present
    pub fn value_as_bool(&self) -> Option<bool> {
        self.value.bool
    }

    /// Returns the fields map if present
    pub fn fields(&self) -> Option<&std::collections::HashMap<String, serde_json::Value>> {
        self.fields.as_ref()
    }

    /// Extract a string field value from the fields map by field name
    pub fn get_field_as_str(&self, field_name: &str) -> Option<&str> {
        self.fields.as_ref()
            .and_then(|f| f.get(field_name))
            .and_then(|v| v.as_str())
    }
}
/// Output parameters for the Describe method.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct DescribeOutput {
    pub name: String,
    pub description: String,
    pub r#type: MetricFamilyType,
}
/// An enum representing various metric family types
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum MetricFamilyType {
    /// A counter metric family type which is a monotonically increasing value
    Counter,
    /// A gauge metric family type which is a value that can go up and down
    Gauge,
    /// A string metric family type
    String,
}

/// Errors that can occur in this interface.
#[derive(Debug, Clone, PartialEq, ReplyError)]
#[zlink(interface = "io.systemd.Metrics")]
pub enum MetricsError {
    /// No such metric found
    NoSuchMetric,
}

impl std::fmt::Display for MetricsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MetricsError::NoSuchMetric => write!(f, "No such metric found"),
        }
    }
}

impl std::error::Error for MetricsError {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_object_name_with_value() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: Some("my-service.service".to_string()),
            fields: None,
        };

        assert_eq!(output.object_name(), "my_service.service");
    }

    #[test]
    fn test_object_name_without_value() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: None,
        };

        assert_eq!(output.object_name(), "");
    }

    #[test]
    fn test_object_name_with_empty_string() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: Some("".to_string()),
            fields: None,
        };

        assert_eq!(output.object_name(), "");
    }

    #[test]
    fn test_object_returns_option() {
        let output_with_object = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: Some("service.service".to_string()),
            fields: None,
        };

        let output_without_object = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: None,
        };

        assert_eq!(output_with_object.object(), Some("service.service"));
        assert_eq!(output_without_object.object(), None);
    }

    #[test]
    fn test_get_field_as_str_existing_field() {
        let mut fields = std::collections::HashMap::new();
        fields.insert("type".to_string(), serde_json::json!("service"));
        fields.insert("state".to_string(), serde_json::json!("active"));

        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: Some(fields),
        };

        assert_eq!(output.get_field_as_str("type"), Some("service"));
        assert_eq!(output.get_field_as_str("state"), Some("active"));
    }

    #[test]
    fn test_get_field_as_str_missing_field() {
        let fields = std::collections::HashMap::new();

        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: Some(fields),
        };

        assert_eq!(output.get_field_as_str("nonexistent"), None);
    }

    #[test]
    fn test_get_field_as_str_no_fields() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: None,
        };

        assert_eq!(output.get_field_as_str("type"), None);
    }

    #[test]
    fn test_get_field_as_str_non_string_value() {
        let mut fields = std::collections::HashMap::new();
        fields.insert("number".to_string(), serde_json::json!(123));
        fields.insert("bool".to_string(), serde_json::json!(true));

        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: Some(fields),
        };

        assert_eq!(output.get_field_as_str("number"), None);
        assert_eq!(output.get_field_as_str("bool"), None);
    }

    #[test]
    fn test_metric_value_as_str() {
        let value = MetricValue {
            string: Some("test".to_string()),
            int: None,
            bool: None,
        };

        assert_eq!(value.as_str(), Some("test"));
    }

    #[test]
    fn test_metric_value_as_string_with_default() {
        let value_with_string = MetricValue {
            string: Some("test".to_string()),
            int: None,
            bool: None,
        };

        let value_empty = MetricValue::default();

        assert_eq!(value_with_string.as_string("default"), "test");
        assert_eq!(value_empty.as_string("default"), "default");
    }

    #[test]
    fn test_metric_value_as_int() {
        let value = MetricValue {
            string: None,
            int: Some(42),
            bool: None,
        };

        let value_empty = MetricValue::default();

        assert_eq!(value.as_int(0), 42);
        assert_eq!(value_empty.as_int(99), 99);
    }

    #[test]
    fn test_metric_value_as_bool() {
        let value_true = MetricValue {
            string: None,
            int: None,
            bool: Some(true),
        };

        let value_false = MetricValue {
            string: None,
            int: None,
            bool: Some(false),
        };

        let value_empty = MetricValue::default();

        assert_eq!(value_true.as_bool(), Some(true));
        assert_eq!(value_false.as_bool(), Some(false));
        assert_eq!(value_empty.as_bool(), None);
    }

    #[test]
    fn test_metric_value_bool_or() {
        let value_true = MetricValue {
            string: None,
            int: None,
            bool: Some(true),
        };

        let value_empty = MetricValue::default();

        assert_eq!(value_true.bool_or(false), true);
        assert_eq!(value_empty.bool_or(false), false);
        assert_eq!(value_empty.bool_or(true), true);
    }

    #[test]
    fn test_name_suffix() {
        let output = ListOutput {
            name: "io.systemd.unit_active_state".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: None,
        };

        assert_eq!(output.name_suffix(), "unit_active_state");
    }

    #[test]
    fn test_name_suffix_no_dots() {
        let output = ListOutput {
            name: "simple_name".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: None,
        };

        assert_eq!(output.name_suffix(), "simple_name");
    }

    #[test]
    fn test_name_suffix_empty() {
        let output = ListOutput {
            name: "".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: None,
        };

        assert_eq!(output.name_suffix(), "");
    }

    #[test]
    fn test_value_as_string_with_value() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue {
                string: Some("active".to_string()),
                int: None,
                bool: None,
            },
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_string("unknown"), "active");
    }

    #[test]
    fn test_value_as_string_without_value() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_string("unknown"), "unknown");
    }

    #[test]
    fn test_value_as_string_empty_string() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue {
                string: Some("".to_string()),
                int: None,
                bool: None,
            },
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_string("default"), "");
    }

    #[test]
    fn test_value_as_int_with_value() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue {
                string: None,
                int: Some(42),
                bool: None,
            },
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_int(0), 42);
    }

    #[test]
    fn test_value_as_int_without_value() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_int(0), 0);
    }

    #[test]
    fn test_value_as_int_zero() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue {
                string: None,
                int: Some(0),
                bool: None,
            },
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_int(0), 0);
    }

    #[test]
    fn test_value_as_int_large_number() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue {
                string: None,
                int: Some(9999999999),
                bool: None,
            },
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_int(0), 9999999999);
    }

    #[test]
    fn test_value_as_bool_true() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue {
                string: None,
                int: None,
                bool: Some(true),
            },
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_bool(), Some(true));
    }

    #[test]
    fn test_value_as_bool_false() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue {
                string: None,
                int: None,
                bool: Some(false),
            },
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_bool(), Some(false));
    }

    #[test]
    fn test_value_as_bool_none() {
        let output = ListOutput {
            name: "test.metric".to_string(),
            value: MetricValue::default(),
            object: None,
            fields: None,
        };

        assert_eq!(output.value_as_bool(), None);
    }
}
